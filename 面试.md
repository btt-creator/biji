### 面试

#### 共致开源

参考：[面试必问问题之多进程与多线程的区别（超详细）_多进程服务端和多线程服务端-CSDN博客](https://blog.csdn.net/m0_46450122/article/details/106462193)

##### 多进程和多线程的区别：

- 多进程就是指计算机同时执行多个程序，进程由程序段、相关数据段以及PCB（程序控制模块）组成，是系统进行资源分配和调度的一个独立单位。进程分为用户进程和系统进程。

- 为什么引入线程：进程是与资源有关的，而进程又是动态的，因此进程进行切换时需要占用系统较多的开销，影响了系统的并发性能，引入了线程，尽量减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

- 什么是多线程：指一个进程中同时有多个线程正在执行，线程是一个基本的cpu执行单元，是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，可以与同属于一个进程的其他线程共享进程所拥有的全部资源。引入线程之后，进程只作为除cpu以外系统资源的分配单元，线程则作为处理机的分配单元。

- 线程的实现可以分为用户级线程和内核级线程，在用户级线程中，有关线程管理的所有工作都有应用程序完成，内核意识不到线程的存在。在内核级线程中，线程管理的所有工作都是内核完成，应用程序无权管理线程。因此可以理解为多线程是一种执行模型，包括多对一模型，一对一模型，多对多模型。
- 多对一模型：将多个用户级线程映射到一个内核级线程，线程管理在用户空间完成。
  优点：线程管理是在用户空间进行的，对于线程的管理不涉及内核的服务，因此效率比较高。
  缺点：由于用户级线程对操作系统不可见，即多个用户级线程实际上操作系统只会认为其只有一个用户级线程，当一个用户级线程在使用内核服务时被阻塞，那么整个进程都会被阻塞，即其他的用户级线程也不能运行了。另外，此模式下，多个线程不能并行地运行在多处理机上。
- 一对一模型：将每个用户级线程映射到一个内核级线程。
  优点：当一个线程被阻塞时，允许另一个线程继续执行，所以并发性能较强。
  缺点：每创建一个用户级线程都需要创建一个内核级线程，这样导致了创建线程的开销较大，会影响程序的性能。
- 多对多模型：将n个用户级线程映射到m个内核级线程，要求m<=n。
  特点：是前两种模型的折中，即克服了多对一模型的并发度不高的缺点，也克服了一对一模型的开销太大的缺点。
- 进程和线程的比较：引入线程之后，线程是独立调度的基本单位，进程是拥有资源的基本单位，不仅进程之间可以并发执行，并且线程之间也可以并发执行，使得操作系统具有更好的并发性，因为线程不拥有系统资源故使用线程调度时系统开销小。

**多进程和多线程的选择：**

单进程单线程：一个人在一个桌子上吃菜。
单进程多线程：多个人在同一个桌子上一起吃菜。
多进程单线程：多个人每个人在自己的桌子上吃菜。

多线程的问题是多个人同时吃一道菜的时候容易发生争抢，例如两个人同时夹一个菜，一个人刚伸出筷子，结果伸到的时候已经被夹走菜了。。。此时就必须等一个人夹一口之后，在还给另外一个人夹菜，也就是说资源共享就会发生冲突争抢。
1。对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对**资源争抢与同步方面**的问题。
2。对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通讯的方法。
开桌子的意思是指创建进程。开销这里主要指的是时间开销。
可以做个实验：创建一个进程，在进程中往内存写若干数据，然后读出该数据，然后退出。此过程重复 1000 次，相当于创建/销毁进程 1000 次。在我机器上的测试结果是：
UbuntuLinux：耗时 0.8 秒
Windows7：耗时 79.8 秒
两者开销大约相差一百倍。
这意味着，在 Windows 中，进程创建的开销不容忽视。换句话说就是，Windows 编程中不建议你创建进程，如果你的程序架构需要大量创建进程，那么最好是切换到 Linux 系统。
大量创建进程的典型例子有两个，一个是 gnu autotools 工具链，用于编译很多开源代码的，他们在 Windows 下编译速度会很慢，因此软件开发人员最好是避免使用 Windows。另一个是服务器，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在 Windows 下运行的效率就会很差。这"可能"也是放眼全世界范围，Linux 服务器远远多于 Windows 服务器的原因。
再次补充：如果你是写服务器端应用的，其实在现在的网络服务模型下，开桌子的开销是可以忽略不计的，因为现在一般流行的是按照 CPU 核心数量开进程或者线程，开完之后在数量上一直保持，进程与线程内部使用协程或者异步通信来处理多个并发连接，因而开进程与开线程的开销可以忽略了。
另外一种新的开销被提上日程：核心切换开销。
现代的体系，一般 CPU 会有多个核心，而多个核心可以同时运行多个不同的线程或者进程。当每个 CPU 核心运行一个进程的时候，由于每个进程的资源都独立，所以 CPU 核心之间切换的时候无需考虑上下文。
当每个 CPU 核心运行一个线程的时候，由于每个线程需要共享资源，所以这些资源必须从 CPU 的一个核心被复制到另外一个核心，才能继续运算，这占用了额外的开销。换句话说，在 CPU 为多核的情况下，多线程在性能上不如多进程。
因而，当前面向多核的服务器端编程中，需要习惯多进程而非多线程。





哈希表：哈希表可以用于快速查找、删除和插入操作。插入和查找的平均时间复杂度都为O(1)。用于python中的字典。

红黑树：红黑树是一种自平衡的二叉树，能够保证基本的插入、删除、查找的时间复杂度都是O(logn)。

五个特点：

1. **节点颜色**：每个节点要么是红色，要么是黑色。
2. **根节点属性**：树的根节点是黑色的。
3. **红色节点属性**：如果一个节点是红色的，则它的两个子节点都是黑色的（也就是说，在红黑树中，红色节点不能相邻）。
4. **黑色高度一致性**：从任一节点到其任何叶子节点的所有路径上的黑色节点数量相同（这个数量称为该节点的黑高）。
5. **叶子节点**：所有的叶子节点（NIL节点，树末端的外部节点）都是黑色的。

区别：如果需要有序遍历或频繁进行范围搜索，红黑树是更好的选择。如果应用场景主要涉及到快速的查找、插入和删除，并且数据顺序不重要，哈希表则是更优的选择。



http和https的区别：http是以明文进行传输的，https进行了加密传输。其中http的端口号为80，而https为443。但是https也存在缺点，即需要花费额外的资源。



tcp的三次握手：即客户端发出连接请求，需要传递数据。服务端确认请求，并且也要传输数据。客户端再确认其服务端的发送数据请求。

![image-20240511213850062](C:\Users\tan\Desktop\实习\面试.assets\image-20240511213850062.png)

为什么需要三次握手，而不是两次？ 答：我们假设client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。

四次、五次的连接请求浪费资源。

tcp四次挥手：

四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

![img](https://pic4.zhimg.com/v2-1b3935fa6bcccddd2d9d1b04d92ef563_r.jpg)





cookie、session、token的区别：

![image-20240511215152453](C:\Users\tan\Desktop\实习\面试.assets\image-20240511215152453.png)





#### 测试

swagger和postman的区别：

- **设计与测试**：Swagger更注重API的设计和文档化，而Postman专注于API的测试和调试。swagger通过在代码里面添加注解，则能自动生成接口文档。
- **使用场景**：Swagger通常在API设计阶段使用，帮助定义API规范并自动生成文档；Postman则更多用于开发和测试阶段，进行API调用和验证。
- **文档与交互**：Swagger自动生成的API文档支持交互，但功能相对有限；Postman提供了更强大的请求构建、发送和测试功能，但不直接提供文档生成工具。



Postman的用法：为了验证我们的RESTful服务，我使用Postman作为主要的API测试工具。我首先在Postman中设置了不同的环境配置，以模拟开发、测试和生产环境的不同情况，确保API在所有环境下都能正确执行。我为每个HTTP方法建立了具体的请求，包括GET请求来获取数据、POST请求来创建新的数据条目、PUT请求来更新已存在的数据，以及DELETE请求来删除不再需要的数据。

测试结果的应用：通过Postman的测试结果，我们能够及时发现和解决API中的问题。例如，在一次测试中，我们发现删除操作没有正确返回预期的状态码，这暴露了后端逻辑的一个缺陷。